\chapter{Design sicuro} 

In questo capitolo sono esposte le scelte utilizzate per la realizzazione di un design sicuro, in modo tale da garantire elevati livelli di \textit{performance, usability e acceptability}, rendendo, però, il sistema sicuro da attacchi esterni.

Nelle successive Sezioni sono riportate le scelte effettuate nei seguenti campi:
\begin{itemize}
    \item \textbf{Architettura}: saranno trattate le scelte architetturali utilizzate;
    \item \textbf{Design degli asset}: saranno trattati i design utilizzati per modellare gli asset;
    \item \textbf{Scelte tecnologiche}: saranno trattate le scelte tecnologiche adottate;
    \item \textbf{Modellazione di una unità mediante Markov Chain}: sarà esposta la modellazione di una unità mediante Markov Chain.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architettura}

Il sistema progettato utilizza una blockchain per il calcolo e la validazione dei valori ottenuti dall'oracolo della rete bayesiana.

La rete bayesiana è composta da due livelli di: 

\begin{itemize}
    \item \textbf{livello dei fatti}, nel quale sono presenti elementi non conosciuti;
    \item \textbf{livello delle prove}, nel quale sono presenti elementi conoscibili.
\end{itemize}

Tutti gli elementi presenti nella rete bayesiana sono rappresentati da variabili aleatorie booleane.
Inoltre, è possibile stimare la probabilità di avvenimento degli elementi presenti nel livello dei fatti mediante il processo di \textbf{inferenza diagnostica}, basandosi, quindi, sui valori booleani delle prove osservate.

L'architettura scelta per l'oracolo bayesiano è divisa in una parte \textit{on-chain} ed una parte \textit{off-chain}; il sistema off-chain contiene le probabilità a priori degli elementi presenti nel livello dei fatti; inoltre, nella parte off-chain è presente la tabella delle probabilità condizionate degli elementi presenti nel livello dei fatti, in funzione delle prove osservate.

La parte on-chain, invece, fornisce le probabilità a priori degli elementi presenti nel livello dei fatti, se non sono stato osservate delle prove.

Inoltre, calcola la probabilità a posteriori degli elementi presenti nel livello dei fatti, mediante l'inferenza diagnostica, in base alle prove osservate.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design degli asset}

 In questa sezione, riportiamo la fase di design degli asset. Essa consiste nello scegliere alcune linee guida proposte da OWASP, Saltzer \& Schroeder e Sommerville, le quali verranno illustrate nelle successive sottosezioni.
 
 Si precisa che alcune linee guida sono comuni tra i vari modelli e sono state selezionate una sola volta.

\subsection{OWASP (Open Worldwide Application Security Project)}

Le linee guida scelte tra quelle proposte da \textit{OWASP} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Principle of Least privilege}, che consiste nel fornire agli account, processi e programmi i privilegi minimi richiesti per eseguire le azioni previste. Ciò riduce il rischio potenziale di provocare danni a seguito di una compromissione del sistema;
    \item \textbf{Fail securely}, che consiste nel permettere al sistema di affrontare dei fallimenti in maniera sicura, cioè evitando che un fallimento porti ad un comportamento insicuro del sistema;
    \item \textbf{Separation of duties}, che consiste nel separare le funzionalità permesse alle varie tipologie di utenti ed al sistema, in modo che nessun utente o processo abbia il controllo completo, riducendo così il rischio di abusi. Questo principio è strettamente collegato al principio del minimo privilegio;
    \item \textbf{Fix security issues correctly}, che consiste nel correggere problematiche di sicurezza correttamente, evitando di peggiorare altre funzionalità non coinvolte;
    \item \textbf{Minimize Attack surface Area}, che consiglia di ridurre la superficie di attacco al fine di diminuire il rischio, limitando i modi che un utente malevolo ha per attaccare il sistema.
\end{itemize}

\subsection{Sommerville}

Le linee guida scelte tra quelle proposte da \textit{Sommerville} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Balance security and usability}, che consiste nel trovare un equilibrio tra la sicurezza e l'usabilità del sistema;
    \item \textbf{Log user actions}, che consiste nel registrare mediante un \textit{log} tutte le attività effettuate all'interno del sistema;
    \item \textbf{Use redundancy and diversity to reduce risk}, che consiste nell'utilizzare ridondanza e diversità per ridurre i rischi di attacchi esterni;
    \item \textbf{Specify the format of all system inputs}, che consiste nello specificare il formato dei valori in output del sistema;
    \item \textbf{Avoid a single point of failure}, che consiste nel progettare il sistema in modo tale da evitare che un singolo componente possa causare il malfunzionamento dell'intero sistema;
    \item \textbf{Fail securely}, molto simile alla linea guida di OWASP, che consiste nel permettere al sistema di affrontare dei fallimenti in maniera sicura, evitando l'esposizione d'informazioni sensibili.
\end{itemize}

\subsection{Saltzer \& Schroeder}

Le linee guida scelte tra quelle proposte da \textit{Saltzer \& Schroeder} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Least Privilege}, simile al principio del minimo privilegio di OWASP, che consiste nel fornire agli account, processi e programmi i privilegi minimi richiesti per eseguire le azioni previste;
    \item \textbf{KISS Principle}, che consiste nel realizzare il sistema di difesa nella maniera più semplice e piccola possibile;
    \item \textbf{Complete mediation}, che consiste nel controllare ogni tentativo di accesso al sistema prima di fornire all'utente o ad altri processi la possibilità di eseguire qualsiasi azione;
    \item \textbf{Psychological acceptability/Easy to use}, che consiste nel rendere l'interazione tra il sistema e dell'utente il più intuitiva possibile, avvalendosi d'interfacce facili da usare.
    \item \textbf{Separation of privilege (defense in-depth)}, che consiste nel far dipendere l'accesso ai vari oggetti da più condizioni, in modo che se una sia bypassata, un attaccante deve anche riuscire a superare le altre condizioni. Un classico esempio è l'autenticazione a più fattori, dove oltre alla password, l'utente deve fornire un secondo fattore per poter accedere al sistema, di solito un codice OTP.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scelte tecnologiche}

In questa sezione sono riportate le scelte tecnologiche adottate per la realizzazione del sistema. Come annunciato in precedenza, il sistema sarà composto da due differenti parti: una parte on-chain ed una parte off-chain. 

\begin{itemize}
            \item \textbf{Linguaggio off-chain}
             \begin{itemize}
                \item \textbf{Python}: la scelta di utilizzare Python come linguaggio off-chain è dovuta alla presenza di numerose librerie che facilitano la connessione con l'oracolo on-chain. Inoltre, Python offre diversi strumenti per garantire la sicurezza del sistema, mediante l'uso di librerie specifiche per la crittografia e la gestione delle vulnerabilità. 
                \item \textbf{JavaScript}: la scelta di utilizzare JavaScript come linguaggio è stata presa per la sua potenzialità e fruibilità nel contesto web, poiché permette l'interfacciamento diretto con il backend, garantendo migliore flessibilità per il sistema.
             \end{itemize}

            \item \textbf{Linguaggio on-chain}
            
             \begin{itemize}
                \item \textbf{Solidity}: è stato scelto di utilizzare Solidity poiché è un linguaggio di programmazione diffuso per scrivere smart contract sulla blockchain di Ethereum. Inoltre, Solidity, essendo versatile, può essere utilizzato per una vasta gamma di applicazioni, come la creazione di token e la gestione di pagamenti.
                
                Un ulteriore motivo della scelta di Solidity è la similitudine del linguaggio con JavaScript, poiché entrambi sono un linguaggio orientato ad oggetti.
             \end{itemize}

            \item \textbf{Database}
            
            \begin{itemize}
                \item \textbf{Supabase}: per la gestione del database, è stato scelto Supabase, una piattaforma
                open-source su cloud che offre un backend-as-a-service basato su PostgreSQL. Inoltre, grazie ai meccanismi nativi di quest’ultimo, esso permette di ottenere risposte in tempo reale, di avere una gestione avanzata delle transazioni e di consentire una scalabilità orizzontale, rendendolo una soluzione solida e affidabile per il nostro sistema.
            \end{itemize}

            \item \textbf{User Interface}   
            
            \begin{itemize}
            \item \textbf{Django}: Django, framework web basato su Python, si è affermato negli anni come una delle soluzioni più mature e affidabili per lo sviluppo di applicazioni web complesse. La sua filosofia
            "batteries included" (cioè comprende molte funzionalità built-in come un pannello admin, ORM, sistema di autenticazione ed altre) e l’approccio pragmatico al problem-solving lo rendono particolarmente adatto per progetti dove la sicurezza, la scalabilità e la rapidità di sviluppo sono requisiti imprescindibili. 

            \item \textbf{HTML}: HTML è il linguaggio di markup standard utilizzato per creare pagine web. La sua semplicità, versatilità e documentazione approfondita lo rendono uno strumento essenziale per la progettazione di interfacce utente efficaci e accessibili. Inoltre, HTML consente una facile integrazione con altri linguaggi e tecnologie web, facilitando lo sviluppo di applicazioni web dinamiche e interattive.
            
            \item \textbf{CSS}: CSS è un linguaggio di stile utilizzato per descrivere la presentazione di un documento HTML. La sua capacità di separare il contenuto dalla presentazione consente una maggiore flessibilità e controllo nella progettazione delle interfacce utente. Inoltre, CSS offre una vasta gamma di funzionalità per la gestione del layout, dei colori, dei font e delle animazioni.
            \end{itemize}

            \item \textbf{Containerizzazione}
            
            \begin{itemize}
                \item \textbf{Docker}: si è scelto Docker per gestire i nodi validatori della blockchain, sfruttando la sua capacità di creare ambienti isolati e facilmente scalabili. Docker consente di containerizzare i nodi, garantendo che ognuno di essi esegua il suo ambiente in modo indipendente e uniforme su qualsiasi sistema, semplificando la gestione, il deployment e il monitoraggio. Inoltre, grazie alla sua portabilità e alla rapida configurazione, Docker permette di distribuire i nodi validatori in modo efficiente e sicuro, migliorando la resilienza dell’infrastruttura. Per orchestrare e gestire i container in modo coordinato, una tecnologia utile è Docker Compose, uno strumento che permette di definire e avviare applicazioni multi-container attraverso un file di configurazione YAML. Grazie a Docker Compose, è possibile specificare facilmente le dipendenze tra i vari servizi, automatizzare l’avvio dei nodi validatori e gestire la configurazione dell’intera infrastruttura in modo centralizzato, facilitando il deployment e la scalabilità del sistema.
            \end{itemize}

            \item \textbf{Blockchain}
            
            \begin{itemize}
                \item \textbf{Ethereum}: è stato scelto Ethereum come piattaforma blockchain per la sua robustezza, sicurezza e ampia adozione. Ethereum offre un'infrastruttura solida per la creazione e l'esecuzione di smart contract, consentendo lo sviluppo di applicazioni decentralizzate con funzionalità avanzate. Inoltre, la vasta comunità di sviluppatori e le risorse disponibili rendono Ethereum una scelta ideale per progetti che richiedono scalabilità e interoperabilità.
                
                \item \textbf{Besu}: è stato scelto Besu come client Ethereum per la sua flessibilità, sicurezza e supporto per diverse reti blockchain. Besu è un client open-source che offre funzionalità avanzate per la gestione dei nodi, la sincronizzazione della blockchain e l'esecuzione di smart contract. Inoltre, Besu supporta sia reti pubbliche che private, consentendo una maggiore personalizzazione e controllo sull'infrastruttura blockchain.
                In particolare, è stato utilizzato per la gestione dei validatori tramite l'algoritmo bizantino di consenso Proof of Authority (PoA), abbreviato con la sigla QBFT (Quorum Byzantine Fault Tolerance), che garantisce un'elevata sicurezza e affidabilità nella validazione delle transazioni. Esso è un evoluzione dell'algoritmo IBFT (Istanbul Byzantine Fault Tolerance).

                \item \textbf{OpenZeppelin}: è stato scelto OpenZeppelin come framework per lo sviluppo di smart contract su Ethereum per la sua affidabilità, sicurezza e facilità d'uso. OpenZeppelin offre una vasta libreria di contratti predefiniti e testati, che consentono agli sviluppatori di creare applicazioni decentralizzate in modo rapido ed efficiente. Inoltre, OpenZeppelin fornisce strumenti avanzati per la gestione della sicurezza, la verifica del codice e l'aggiornamento dei contratti, garantendo un elevato livello di protezione contro le vulnerabilità.
            \end{itemize}
            
            \item \textbf{Strategie di difesa}
            
            \begin{itemize}
                    \item \textbf{Multi Factor Authentication (MFA)}: adottata in ottica di \textit{defense in-depth} per rafforzare gli accessi. La Multi Factor Authentication richiede più fattori durante il login, riducendo il rischio di compromissione anche se uno dei fattori viene esposto.
                    \item \textbf{Log user action}: registrazione e monitoraggio sistematico delle attività utente per garantire tracciabilità e conformità. La raccolta e l’analisi dei log permettono di individuare anomalie, supportare audit e indagini forensi e prevenire minacce.
                    \item \textbf{Recupero password}: previsto un reset tramite link email per ripristinare l’accesso in caso di smarrimento. La misura applica il principio \textit{Avoid a single point of failure}, evitando blocchi definitivi e incrementando la resilienza.
                    \item \textbf{Validare tutti gli input al sistema}: la validazione impone formati e vincoli attesi sui dati in ingresso, prevenendo errori e manipolazioni. È in linea con \textit{Specify the format of all system inputs}, poiché ogni input viene verificato prima dell’elaborazione.
                    \item \textbf{Crittografia per dati sensibili}: uso di algoritmi aggiornati per proteggere informazioni riservate di sistema e utenti. La cifratura rende i dati illeggibili senza le chiavi corrette, tutela la privacy e favorisce la conformità al GDPR.
                    \item \textbf{Limitare tentativi di log‑in (Rate limiter)}: introdotta una soglia ai tentativi in una finestra temporale per mitigare attacchi di Brute Force, abbassando drasticamente la probabilità di successo e l’esposizione del sistema.
                    \item \textbf{Politiche di password robuste}: richieste credenziali complesse, come l'utilizzo di lettere maiuscole e minuscole, numeri, simboli ed una lunghezza minima per ostacolare furti di account e forza bruta, riducendo gli accessi non autorizzati.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modellazione tramite Catena di Markov}

Le catene di Markov sono modelli matematici utilizzati per descrivere sistemi che evolvono nel tempo in modo stocastico, cioè in modo probabilistico, basandosi sul principio di Markov, secondo cui il futuro stato del sistema dipende solo dallo stato attuale e non dalla storia passata, ma solo dall'ultima osservazione. Nel nostro caso, le catene di Markov sono state utilizzate per modellare il comportamento di una parte del sistema, rappresentando i vari stati in cui esso può trovarsi e le transizioni tra questi stati, descritte da funzioni di probabilità di transizione.

\subsection{Catena di Markov per la funzione di login}

È stato deciso di modellare la funzione di login del sistema mediante una catena di Markov, al fine di analizzare il comportamento degli utenti durante il processo di autenticazione, fondamentale nei sistemi informatici. La catena di Markov per la funzione di login è composta da 12 stati e 4 contatori:

\begin{itemize}
    \item \textbf{$C_{LOG}$}: contatore dei tentativi di login (inserimento username e password);
    \item \textbf{$C_{RPASS}$}: contatore d'inserimento del codice per il recupero della password;
    \item \textbf{$C_{MFA}$}: contatore dei tentativi d'inserimento del codice MFA;
    \item \textbf{$C_{EMAIL}$}: contatore dell'inserimento delle email nel campo recupero password.
\end{itemize}

Lo stato iniziale della catena di Markov è lo stato \textbf{0}, che rappresenta l'utente che apre la schermata di login, nella quale egli può inserire le proprie credenziali (username e password). Qui abbiamo la prima biforcazione, se l'utente sceglie di recuperare la propria password, si passa allo stato \textbf{5} tramite la transizione etichettata con \textit{/PasswordDimenticata}, altrimenti si passa allo stato \textbf{1} con etichetta \textit{/InserimentoDati}. 

Vediamo la transizione che riguarda l'inserimento dei dati di login: dallo stato \textbf{0}, dopo l'inserimento delle credenziali da parte dell'utente, si passa allo stato \textbf{1} e viene incrementato il counter dei tentativi $C_{LOG}$ di 1. Se le credenziali sono corrette, si passa allo stato \textbf{2} tramite la transizione etichettata con \textit{?DatiOK}, altrimenti, se le credenziali sono sbagliate ed il contatore $C_{LOG}$ è minore di 5, si torna allo stato \textbf{0} tramite la transizione etichettata con \textit{?DatiKO}; se il contatore è uguale a 5, si va nello stato \textbf{11} con la stessa transizione \textit{?DatiKO}, che rappresenta uno stato di timeout dopo un certo numero di azioni e si rimane in questo stato indefinitamente tramite la transizione \textit{?Timeout}. Per quanto riguarda lo stato \textbf{2}, esso rappresenta l'inserimento del codice MFA. Dopo l'inserimento di quest'ultimo, il contatore $C_{MFA}$ viene incrementato di 1 e si fa una transizione nello stato \textbf{3}. Se il codice è corretto, si passa allo stato \textbf{4} tramite la transizione etichettata con \textit{?CodiceOK}, questo rappresenta lo stato con cui il login è avvenuto con successo e vi si rimane indefinitamente (l'etichetta è \textit{?LoginEffettuato}). Se il codice MFA è errato e il contatore $C_{MFA}$ è minore di 5, si torna allo stato \textbf{2} tramite la transizione etichettata con \textit{?CodiceKO}, quindi viene chiesto nuovamente all'utente d'inserire il codice MFA; se il contatore è uguale a 5, si va nello stato \textbf{11} con la transazione con la stessa etichetta e, come detto precedentemente, rappresenta lo stato di timeout. Infine, vi è un'ultima transizione etichettata \textit{/RinvioCodiceMFA}, che permette all'utente di farsi rinviare il codice MFA, rimanendo nello stato \textbf{2}; se il contatore $C_{MFA}$ arriva a 5, si va nello stato di timeout \textbf{11}, rappresenta una limitazione nell'invio da parte del sistema dei codici MFA.

Invece, se l'utente sceglie di recuperare la propria password, si passa allo stato \textbf{5}. Qui, dopo che l'utente ha inserito l'email su cui effettuare il recupero della password, viene incrementato il contatore $C_{EMAIL}$ di 1. Si passa allo stato \textbf{6}, in cui il sistema controlla se l'email è presente nel database. Se l'email non esiste ed il contatore $C_{EMAIL}$ è minore di 5, si torna allo stato \textbf{5} e viene chiesto nuovamente all'utente d'inserire un'email valida. Se il contatore è uguale a 5, si va nello stato \textbf{11} con la transizione etichettata con \textit{?EmailKO}. Se l'email è corretta, si passa allo stato \textbf{7} tramite la transizione etichettata con \textit{?EmailOK}. In questo stato, il sistema invia una email all'utente con un codice per reimpostare la password; a questo punto l'utente deve inserire il codice ricevuto, incrementando il contatore $C_{RPASS}$ di 1 e si transita allo stato \textbf{8} con l'etichetta \textit{/InserimentoCodice}. Se il codice è corretto, si passa allo stato \textbf{9} tramite la transizione etichettata con \textit{?CodiceOK}. In questo stato si chiede all'utente d'inserire una nuova password. Dopo averla inserita si transita nello stato \textbf{10} con etichetta \textit{/!InserimentoNuovaPassword}; se la password soddisfa i criteri richiesti dal sistema, si transita allo stato \textbf{0} tramite l'etichetta \textit{?NuovaPasswordOK}, e l'utente può iniziare nuovamente la fase di login. Invece, se la nuova password non soddisfa i criteri richiesti, si torna nello stato \textbf{9} tramite la transizione etichettata con \textit{?NuovaPasswordKO}, quindi viene chiesto nuovamente all'utente d'inserire una nuova password.

Tornando indietro allo stato \textbf{8}, se il codice di recupero password è errato ed il contatore $C_{RPASS}$ è minore di 5, si torna allo stato \textbf{7} tramite la transizione etichettata con \textit{?CodiceKO}, quindi viene chiesto nuovamente all'utente d'inserire il codice; se il contatore è uguale a 5, si va nello stato \textbf{11} di timeout. Infine, nello stato \textbf{7} vi è un'ultima transizione etichettata \textit{/RinvioCodicePASS}, che permette all'utente di farsi rinviare il codice per il recupero della password, rimanendo nello stato \textbf{7}; se il contatore $C_{RPASS}$ arriva a 5, si va nello stato di timeout \textbf{11}, rappresenta una limitazione nell'invio da parte del sistema dei codici per il recupero della password.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/catenaDiMarkov.png}
\end{figure}

\subsection{Modellazione della funzione di login tramite PRISM}

Per analizzare la catena di Markov della funzione di login, è stato utilizzato il tool PRISM, un software per la modellazione e l'analisi di sistemi stocastici. PRISM consente di definire modelli formali, come le catene di Markov, e di eseguire analisi quantitative su di essi. Il modello formale usato per modellare la funzione di login è una \textbf{Discrete-Time Markov Chain (DTMC)}, che rappresenta un sistema che evolve nel tempo in modo discreto, con transizioni tra stati che avvengono in modo probabilistico. Ciò permette anche l'analisi di proprietà che il sistema dovrebbe soddisfare. Di seguito è riportato il codice PRISM utilizzato per il modello:

%%%%%%%%%%INSERISCI MODEL PRISM QUI%%%%%%%%%%%%
%\mintedprism{chapter3/loginV2.prism}

\begin{highlightPrism}
\keyword{dtmc}

\keyword{module} \variable{login\_function}

\variable{p1} : [\numberb{0}..\numberb{27}] \keyword{init} \numberb{0};
\variable{c\_log} : [\numberb{0}..\numberb{5}] \keyword{init} \numberb{0};
\variable{c\_mfa} : [\numberb{0}..\numberb{5}] \keyword{init} \numberb{0};
\variable{c\_rpass} : [\numberb{0}..\numberb{5}] \keyword{init} \numberb{0};
\variable{c\_email} : [\numberb{0}..\numberb{5}] \keyword{init} \numberb{0};

% uscenti da stato 0
\bracketcontent{} (\variable{p1}=\numberb{0}) -\gt \numberb{0.8}:(\variable{p1}'=\numberb{12}) \&
(\variable{c\_log}' = \keyword{min}(\variable{c\_log} + \numberb{1}, \numberb{5}))
+ \numberb{0.2}:(\variable{p1}'=\numberb{13});

\bracketcontent{inserimentodati} (\variable{p1}=\numberb{12}) -\gt (\variable{p1}'=\numberb{1});
\bracketcontent{PasswordDimentica} (\variable{p1}=\numberb{13}) -\gt (\variable{p1}'=\numberb{5});

% uscenti da stato 1
\bracketcontent{} (\variable{p1}=\numberb{1}) \& (\variable{c\_log}\lt\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{14})
+ \numberb{0.8}:(\variable{p1}'=\numberb{15});

\bracketcontent{} (\variable{p1}=\numberb{1}) \& (\variable{c\_log}=\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{11})
+ \numberb{0.8}:(\variable{p1}'=\numberb{15});

\bracketcontent{datiKO} (\variable{p1}=\numberb{14}) \& (\variable{c\_log}\lt\numberb{5})
-\gt (\variable{p1}'=\numberb{0});

\bracketcontent{datiOK} \variable{p1}=\numberb{15} -\gt (\variable{p1}'=\numberb{2});
\bracketcontent{datiKO} \variable{p1}=\numberb{16} \& \variable{c\_log}=\numberb{5}
-\gt (\variable{p1}'=\numberb{11});

% uscenti da stato 2
\bracketcontent{} (\variable{p1}=\numberb{2}) -\gt
\numberb{0.2}:(\variable{p1}'=\numberb{17})
+ \numberb{0.8}:(\variable{p1}'=\numberb{16}) \&
(\variable{c\_mfa}' = \keyword{min}(\variable{c\_mfa} + \numberb{1}, \numberb{5}));

\bracketcontent{inserimentoCodice} (\variable{p1}=\numberb{16}) -\gt (\variable{p1}'=\numberb{3});
\bracketcontent{rinviocodicemfa} (\variable{p1}=\numberb{17}) -\gt (\variable{p1}'=\numberb{2});

% uscenti dallo stato 3
\bracketcontent{} (\variable{p1}=\numberb{3}) \& (\variable{c\_mfa}\lt\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{19})
+ \numberb{0.8}:(\variable{p1}'=\numberb{18});

\bracketcontent{} (\variable{p1}=\numberb{3}) \& (\variable{c\_mfa}=\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{11})
+ \numberb{0.8}:(\variable{p1}'=\numberb{18});

\bracketcontent{codiceKO} (\variable{p1}=\numberb{19}) \& (\variable{c\_mfa}\lt\numberb{5})
-\gt (\variable{p1}'=\numberb{2});
\bracketcontent{codiceOK} \variable{p1}=\numberb{18} -\gt (\variable{p1}'=\numberb{4});

% uscenti da 5
\bracketcontent{inserimentoemail} \variable{p1}=\numberb{5} -\gt
(\variable{p1}'=\numberb{6}) \&
(\variable{c\_email}' = \keyword{min}(\variable{c\_email} + \numberb{1}, \numberb{5}));

% uscenti da 6
\bracketcontent{} (\variable{p1}=\numberb{6}) \& (\variable{c\_email}\lt\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{21})
+ \numberb{0.8}:(\variable{p1}'=\numberb{20});

\bracketcontent{} (\variable{p1}=\numberb{6}) \& (\variable{c\_email}=\numberb{5})
-\gt \numberb{0.2}:(\variable{p1}'=\numberb{11})
+ \numberb{0.8}:(\variable{p1}'=\numberb{20});

\bracketcontent{emailKO} (\variable{p1}=\numberb{21}) \& (\variable{c\_email}\lt\numberb{5})
-\gt (\variable{p1}'=\numberb{5});
\bracketcontent{emailOK} \variable{p1}=\numberb{20} -\gt (\variable{p1}'=\numberb{7});

% uscenti da 7
\bracketcontent{} (\variable{p1}=\numberb{7}) -\gt
\numberb{0.2}:(\variable{p1}'=\numberb{23})
+ \numberb{0.8}:(\variable{p1}'=\numberb{22}) \&
(\variable{c\_rpass}' = \keyword{min}(\variable{c\_rpass} + \numberb{1}, \numberb{5}));

\bracketcontent{rinviocodicepass} (\variable{p1}=\numberb{23}) -\gt (\variable{p1}'=\numberb{7});
\bracketcontent{inserimentocodice} \variable{p1}=\numberb{22} -\gt (\variable{p1}'=\numberb{8});

% uscenti da 8
\bracketcontent{} (\variable{p1}=\numberb{8}) \& (\variable{c\_rpass}\lt\numberb{5})
-\gt \numberb{0.1}:(\variable{p1}'=\numberb{25})
+ \numberb{0.9}:(\variable{p1}'=\numberb{24});

\bracketcontent{} (\variable{p1}=\numberb{8}) \& (\variable{c\_rpass}=\numberb{5})
-\gt \numberb{0.1}:(\variable{p1}'=\numberb{11})
+ \numberb{0.9}:(\variable{p1}'=\numberb{24});

\bracketcontent{codiceKO} (\variable{p1}=\numberb{25}) \& (\variable{c\_rpass}\lt\numberb{5})
-\gt (\variable{p1}'=\numberb{7});
\bracketcontent{codiceOK} (\variable{p1}=\numberb{24}) -\gt (\variable{p1}'=\numberb{9});

% uscenti da 9
\bracketcontent{inserimentonuovapassword} (\variable{p1}=\numberb{9}) -\gt (\variable{p1}'=\numberb{10});

% uscenti da 10
\bracketcontent{} (\variable{p1}=\numberb{10})
-\gt \numberb{0.1}:(\variable{p1}'=\numberb{27})
+ \numberb{0.9}:(\variable{p1}'=\numberb{26});

\bracketcontent{nuovapasswordKO} \variable{p1}=\numberb{27} -\gt (\variable{p1}'=\numberb{9});
\bracketcontent{nuovapasswordOK} \variable{p1}=\numberb{26} -\gt (\variable{p1}'=\numberb{0});

\keyword{endmodule}
\end{highlightPrism}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simulazione tramite PRISM}

Sfruttando il simulatore di PRISM, sono state eseguite delle simulazioni per analizzare il comportamento del sistema in diversi scenari. Di seguito sono riportate alcune simulazioni:

\subsubsection{Simulazione login corretto}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_login_corretto.png}
    \caption{Utente che effettua il login correttamente.}
\end{figure}

La figura 3.1 mostra la simulazione del login da parte di un utente che inserisce correttamente le proprie credenziali e il codice MFA. Si può notare che si arriva in una situazione di deadlock dopo aver effettuato il login con successo, ciò equivale a rimanere indefinitamente nello stato 4.

\clearpage

\subsubsection{Simulazione login errato}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_credenziali_sbagliate_x5.png}
    \caption{Timeout login con credenziali sbagliate 5 volte.}
\end{figure}

La figura 3.2 mostra la simulazione del login da parte di un utente che inserisce credenziali errate per 5 volte consecutive, raggiungendo così lo stato di timeout.

\clearpage

\subsubsection{Simulazione recupero password corretto}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_recupero_password_corretto.png}
    \caption{Utente che effettua il recupero della propria password correttamente.}
\end{figure}

La figura 3.3 mostra la simulazione del recupero della password da parte di un utente che inserisce correttamente l'email, il codice di recupero e la nuova password. Alla fine del processo di recupero, l'utente torna allo stato iniziale per effettuare nuovamente il login.

\clearpage

\subsubsection{Simulazione MFA errato}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_sbaglio_codice_MFA.png}
    \caption{Utente che inserisce correttamente le credenziali, ma sbaglia il codice MFA.}
\end{figure}

La figura 3.4 mostra la simulazione di un utente che inserisce correttamente le credenziali, ma sbaglia il codice MFA per 5 volte consecutive, raggiungendo così lo stato di timeout. Questo scenario evidenzia l'importanza dei sistemi di autenticazione a più fattori.

\clearpage

\subsubsection{Simulazione codice recupero password errato}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_codice_recupero_password_sbagliato.png}
    \caption{Utente che inserisce correttamente l'email, ma sbaglia il codice di recupero password.}
\end{figure}

La figura 3.5 mostra la simulazione di un utente che inserisce correttamente l'email per il recupero della password, ma sbaglia il codice di recupero per 5 volte consecutive, raggiungendo così lo stato di timeout.

\clearpage

\subsubsection{Simulazione recupero password e login corretto}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/Simulazione_recupero_password_e_login_corretto.png}
    \caption{Utente effettua la procedura di recupero password e poi effettua il login correttamente.}
\end{figure}

La figura 3.6 mostra la simulazione di un utente che effettua la procedura di recupero della password in modo corretto e, successivamente, effettua il login con successo usando la nuova password appena cambiata.

\subsection{Verifica di una proprietà di Safety}

La proprietà di \textit{Safety} rappresenta il concetto che "qualcosa di brutto non accada mai" durante l'esecuzione di un sistema. In altre parole, una proprietà di Safety garantisce che il sistema non raggiunga mai uno stato indesiderato o pericoloso. Nel contesto della funzione di login modellata tramite la catena di Markov, una proprietà di Safety potrebbe essere formulata come segue: "Un utente non deve mai superare il numero massimo di tentativi di login errati senza essere bloccato". Questa proprietà può essere rappresentata in PRISM tramite la seguente stringa: 
\begin{verbatim}
    P=? [ F ((c_log=5|c_mfa=5|c_email=5|c_rpass=5)&p1!=11) ]
\end{verbatim}

Ci chiediamo qual'è la probabilità di raggiungere uno stato in cui uno dei contatori ($C_{LOG}$, $C_{MFA}$, $C_{EMAIL}$, $C_{RPASS}$) è uguale a 5 (cioè il numero massimo di tentativi errati) e lo stato corrente (p1) non è lo stato di timeout (stato 11)? In altre parole, questa proprietà garantisce che il sistema bloccherà l'utente dopo un certo numero di tentativi errati, prevenendo così accessi non autorizzati.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.6\columnwidth]{chapter3/immagini/safety.png}
    \caption{Verifica della proprietà di Safety tramite PRISM.}
\end{figure}

Usando la funzione \textit{Verify} di PRISM, è stato possibile verificare questa proprietà di Safety sul modello della funzione di login. La verifica ha confermato che la proprietà è soddisfatta, infatti figura 3.7 mostra che la probabilità di raggiungere uno stato in cui uno dei contatori è uguale a 5 e lo stato corrente non è lo stato di timeout è praticamente pari a 0. Ciò significa che il sistema bloccherà sempre l'utente dopo un certo numero di tentativi errati, garantendo così la sicurezza del processo di autenticazione.

\subsection{Verifica di una proprietà di response}

La proprietà di \textit{Response} rappresenta il concetto che "se qualcosa di buono accade, allora qualcosa di buono deve accadere sempre". In altre parole, una proprietà di response garantisce che se un evento desiderato si verifica, allora un altro evento desiderato deve seguire. Si è deciso di modellare la "un utente con le credenziali corrette deve riuscire ad acceder al sistema infinitamente spesso". Questa proprietà può essere rappresentata in PRISM tramite la seguente stringa: 
\begin{verbatim}
    P=? [ F p1=4 ]
\end{verbatim}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.6\columnwidth]{chapter3/immagini/response.png}
    \caption{Verifica della proprietà di Response tramite PRISM.}
\end{figure}

Anche questa proprietà è stata verificata utilizzando la funzione \textit{Verify} di PRISM sul modello della funzione di login. La verifica ha confermato che la proprietà è soddisfatta, infatti figura 3.8 mostra che la probabilità di raggiungere lo stato 4 (login effettuato con successo) è praticamente pari a 1. Ciò significa che un utente con le credenziali corrette riuscirà sempre ad accedere al sistema, garantendo così l'accessibilità del processo di autenticazione.
