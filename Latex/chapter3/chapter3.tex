\chapter{Design sicuro} 

In questo capitolo sono esposte le scelte utilizzate per la realizzazione di un design sicuro, in modo tale da garantire elevati livelli di \textit{performance, usability e acceptability}, rendendo, però, il sistema sicuro da attacchi esterni.

Nelle successive Sezioni sono riportate le scelte effettuate nei seguenti campi:
\begin{itemize}
    \item \textbf{Architettura}: saranno trattate le scelte architetturali utilizzate;
    \item \textbf{Design degli asset}: saranno trattati i design utilizzati per modellare gli asset;
    \item \textbf{Scelte tecnologiche}: saranno trattate le scelte tecnologiche adottate;
    \item \textbf{Modellazione di una unità mediante Markov Chain}: sarà esposta la modellazione di una unità mediante Markov Chain.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architettura}

Il sistema progettato utilizza una blockchain per il calcolo e la validazione dei valori ottenuti dall'oracolo della rete bayesiana.

La rete bayesiana è composta da due livelli di: 

\begin{itemize}
    \item \textbf{livello dei fatti}, nel quale sono presenti elementi non conosciuti;
    \item \textbf{livello delle prove}, nel quale sono presenti elementi conoscibili.
\end{itemize}

Tutti gli elementi presenti nella rete bayesiana sono rappresentati da variabili aleatorie booleane.
Inoltre, è possibile stimare la probabilità di avvenimento degli elementi presenti nel livello dei fatti mediante il processo di \textbf{inferenza diagnostica}, basandosi, quindi, sui valori booleani delle prove osservate.

L'architettura scelta per l'oracolo bayesiano è divisa in una parte \textit{on-chain} ed una parte \textit{off-chain}; il sistema off-chain contiene le probabilità a priori degli elementi presenti nel livello dei fatti; inoltre, nella parte off-chain è presente la tabella delle probabilità condizionate degli elementi presenti nel livello dei fatti, in funzione delle prove osservate.

La parte on-chain, invece, fornisce le probabilità a priori degli elementi presenti nel livello dei fatti, se non sono stato osservate delle prove.

Inoltre, calcola la probabilità a posteriori degli elementi presenti nel livello dei fatti, mediante l'inferenza diagnostica, in base alle prove osservate.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design degli asset}

 In questa sezione, riportiamo la fase di design degli asset. Essa consiste nello scegliere alcune linee guida proposte da OWASP, Saltzer \& Schroeder e Sommerville, le quali verranno illustrate nelle successive sottosezioni.
 
 Si precisa che alcune linee guida sono comuni tra i vari modelli e sono state selezionate una sola volta.

\subsection{OWASP (Open Worldwide Application Security Project)}

Le linee guida scelte tra quelle proposte da \textit{OWASP} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Principle of Least privilege}, che consiste nel fornire agli account, processi e programmi i privilegi minimi richiesti per eseguire le azioni previste. Ciò riduce il rischio potenziale di provocare danni a seguito di una compromissione del sistema;
    \item \textbf{Fail securely}, che consiste nel permettere al sistema di affrontare dei fallimenti in maniera sicura, cioè evitando che un fallimento porti ad un comportamento insicuro del sistema;
    \item \textbf{Separation of duties}, che consiste nel separare le funzionalità permesse alle varie tipologie di utenti ed al sistema, in modo che nessun utente o processo abbia il controllo completo, riducendo così il rischio di abusi. Questo principio è strettamente collegato al principio del minimo privilegio;
    \item \textbf{Fix security issues correctly}, che consiste nel correggere problematiche di sicurezza correttamente, evitando di peggiorare altre funzionalità non coinvolte;
    \item \textbf{Minimize Attack surface Area}, che consiglia di ridurre la superficie di attacco al fine di diminuire il rischio, limitando i modi che un utente malevolo ha per attaccare il sistema.
\end{itemize}

\subsection{Sommerville}

Le linee guida scelte tra quelle proposte da \textit{Sommerville} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Balance security and usability}, che consiste nel trovare un equilibrio tra la sicurezza e l'usabilità del sistema;
    \item \textbf{Log user actions}, che consiste nel registrare mediante un \textit{log} tutte le attività effettuate all'interno del sistema;
    \item \textbf{Use redundancy and diversity to reduce risk}, che consiste nell'utilizzare ridondanza e diversità per ridurre i rischi di attacchi esterni;
    \item \textbf{Specify the format of all system inputs}, che consiste nello specificare il formato dei valori in output del sistema;
    \item \textbf{Avoid a single point of failure}, che consiste nel progettare il sistema in modo tale da evitare che un singolo componente possa causare il malfunzionamento dell'intero sistema;
    \item \textbf{Fail securely}, molto simile alla linea guida di OWASP, che consiste nel permettere al sistema di affrontare dei fallimenti in maniera sicura, evitando l'esposizione d'informazioni sensibili.
\end{itemize}

\subsection{Saltzer \& Schroeder}

Le linee guida scelte tra quelle proposte da \textit{Saltzer \& Schroeder} sono state scelte le seguenti:

\begin{itemize}
    \item \textbf{Least Privilege}, simile al principio del minimo privilegio di OWASP, che consiste nel fornire agli account, processi e programmi i privilegi minimi richiesti per eseguire le azioni previste;
    \item \textbf{KISS Principle}, che consiste nel realizzare il sistema di difesa nella maniera più semplice e piccola possibile;
    \item \textbf{Complete mediation}, che consiste nel controllare ogni tentativo di accesso al sistema prima di fornire all'utente o ad altri processi la possibilità di eseguire qualsiasi azione;
    \item \textbf{Psychological acceptability/Easy to use}, che consiste nel rendere l'interazione tra il sistema e dell'utente il più intuitiva possibile, avvalendosi d'interfacce facili da usare.
    \item \textbf{Separation of privilege (defense in-depth)}, che consiste nel far dipendere l'accesso ai vari oggetti da più condizioni, in modo che se una sia bypassata, un attaccante deve anche riuscire a superare le altre condizioni. Un classico esempio è l'autenticazione a più fattori, dove oltre alla password, l'utente deve fornire un secondo fattore per poter accedere al sistema, di solito un codice OTP.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scelte tecnologiche}

In questa sezione sono riportate le scelte tecnologiche adottate per la realizzazione del sistema. Come annunciato in precedenza, il sistema sarà composto da due differenti parti: una parte on-chain ed una parte off-chain. 

\begin{itemize}
            \item \textbf{Linguaggio off-chain}
             \begin{itemize}
                \item \textbf{Python}: la scelta di utilizzare Python come linguaggio off-chain è dovuta alla presenza di numerose librerie che facilitano la connessione con l'oracolo on-chain. Inoltre, Python offre diversi strumenti per garantire la sicurezza del sistema, mediante l'uso di librerie specifiche per la crittografia e la gestione delle vulnerabilità. 
                \item \textbf{JavaScript}: la scelta di utilizzare JavaScript come linguaggio è stata presa per la sua potenzialità e fruibilità nel contesto web, poiché permette l'interfacciamento diretto con il backend, garantendo migliore flessibilità per il sistema.
             \end{itemize}

            \item \textbf{Linguaggio on-chain}
            
             \begin{itemize}
                \item \textbf{Solidity}: è stato scelto di utilizzare Solidity poiché è un linguaggio di programmazione diffuso per scrivere smart contract sulla blockchain di Ethereum. Inoltre, Solidity, essendo versatile, può essere utilizzato per una vasta gamma di applicazioni, come la creazione di token e la gestione di pagamenti.
                
                Un ulteriore motivo della scelta di Solidity è la similitudine del linguaggio con JavaScript, poiché entrambi sono un linguaggio orientato ad oggetti.
             \end{itemize}

            \item \textbf{Database}
            
            \begin{itemize}
                \item \textbf{Supabase}: per la gestione del database, è stato scelto Supabase, una piattaforma
                open-source su cloud che offre un backend-as-a-service basato su PostgreSQL. Inoltre, grazie ai meccanismi nativi di quest’ultimo, esso permette di ottenere risposte in tempo reale, di avere una gestione avanzata delle transazioni e di consentire una scalabilità orizzontale, rendendolo una soluzione solida e affidabile per il nostro sistema.
            \end{itemize}

            \item \textbf{User Interface}   
            
            \begin{itemize}
            \item \textbf{Django}: Django, framework web basato su Python, si è affermato negli anni come una delle soluzioni più mature e affidabili per lo sviluppo di applicazioni web complesse. La sua filosofia
            "batteries included" (cioè comprende molte funzionalità built-in come un pannello admin, ORM, sistema di autenticazione ed altre) e l’approccio pragmatico al problem-solving lo rendono particolarmente adatto per progetti dove la sicurezza, la scalabilità e la rapidità di sviluppo sono requisiti imprescindibili. 

            \item \textbf{HTML}: HTML è il linguaggio di markup standard utilizzato per creare pagine web. La sua semplicità, versatilità e documentazione approfondita lo rendono uno strumento essenziale per la progettazione di interfacce utente efficaci e accessibili. Inoltre, HTML consente una facile integrazione con altri linguaggi e tecnologie web, facilitando lo sviluppo di applicazioni web dinamiche e interattive.
            
            \item \textbf{CSS}: CSS è un linguaggio di stile utilizzato per descrivere la presentazione di un documento HTML. La sua capacità di separare il contenuto dalla presentazione consente una maggiore flessibilità e controllo nella progettazione delle interfacce utente. Inoltre, CSS offre una vasta gamma di funzionalità per la gestione del layout, dei colori, dei font e delle animazioni.
            \end{itemize}

            \item \textbf{Containerizzazione}
            
            \begin{itemize}
                \item \textbf{Docker}: si è scelto Docker per gestire i nodi validatori della blockchain, sfruttando la sua capacità di creare ambienti isolati e facilmente scalabili. Docker consente di containerizzare i nodi, garantendo che ognuno di essi esegua il suo ambiente in modo indipendente e uniforme su qualsiasi sistema, semplificando la gestione, il deployment e il monitoraggio. Inoltre, grazie alla sua portabilità e alla rapida configurazione, Docker permette di distribuire i nodi validatori in modo efficiente e sicuro, migliorando la resilienza dell’infrastruttura. Per orchestrare e gestire i container in modo coordinato, una tecnologia utile è Docker Compose, uno strumento che permette di definire e avviare applicazioni multi-container attraverso un file di configurazione YAML. Grazie a Docker Compose, è possibile specificare facilmente le dipendenze tra i vari servizi, automatizzare l’avvio dei nodi validatori e gestire la configurazione dell’intera infrastruttura in modo centralizzato, facilitando il deployment e la scalabilità del sistema.
            \end{itemize}

            \item \textbf{Blockchain}
            
            \begin{itemize}
                \item \textbf{Ethereum}: è stato scelto Ethereum come piattaforma blockchain per la sua robustezza, sicurezza e ampia adozione. Ethereum offre un'infrastruttura solida per la creazione e l'esecuzione di smart contract, consentendo lo sviluppo di applicazioni decentralizzate con funzionalità avanzate. Inoltre, la vasta comunità di sviluppatori e le risorse disponibili rendono Ethereum una scelta ideale per progetti che richiedono scalabilità e interoperabilità.
                
                \item \textbf{Besu}: è stato scelto Besu come client Ethereum per la sua flessibilità, sicurezza e supporto per diverse reti blockchain. Besu è un client open-source che offre funzionalità avanzate per la gestione dei nodi, la sincronizzazione della blockchain e l'esecuzione di smart contract. Inoltre, Besu supporta sia reti pubbliche che private, consentendo una maggiore personalizzazione e controllo sull'infrastruttura blockchain.
                In particolare, è stato utilizzato per la gestione dei validatori tramite l'algoritmo bizantino di consenso Proof of Authority (PoA), abbreviato con la sigla QBFT (Quorum Byzantine Fault Tolerance), che garantisce un'elevata sicurezza e affidabilità nella validazione delle transazioni. Esso è un evoluzione dell'algoritmo IBFT (Istanbul Byzantine Fault Tolerance).

                \item \textbf{OpenZeppelin}: è stato scelto OpenZeppelin come framework per lo sviluppo di smart contract su Ethereum per la sua affidabilità, sicurezza e facilità d'uso. OpenZeppelin offre una vasta libreria di contratti predefiniti e testati, che consentono agli sviluppatori di creare applicazioni decentralizzate in modo rapido ed efficiente. Inoltre, OpenZeppelin fornisce strumenti avanzati per la gestione della sicurezza, la verifica del codice e l'aggiornamento dei contratti, garantendo un elevato livello di protezione contro le vulnerabilità.
            \end{itemize}
            
            \item \textbf{Strategie di difesa}
            
            \begin{itemize}
                    \item \textbf{Multi Factor Authentication (MFA)}: adottata in ottica di \textit{defense in-depth} per rafforzare gli accessi. La Multi Factor Authentication richiede più fattori durante il login, riducendo il rischio di compromissione anche se uno dei fattori viene esposto.
                    \item \textbf{Log user action}: registrazione e monitoraggio sistematico delle attività utente per garantire tracciabilità e conformità. La raccolta e l’analisi dei log permettono di individuare anomalie, supportare audit e indagini forensi e prevenire minacce.
                    \item \textbf{Recupero password}: previsto un reset tramite link email per ripristinare l’accesso in caso di smarrimento. La misura applica il principio \textit{Avoid a single point of failure}, evitando blocchi definitivi e incrementando la resilienza.
                    \item \textbf{Validare tutti gli input al sistema}: la validazione impone formati e vincoli attesi sui dati in ingresso, prevenendo errori e manipolazioni. È in linea con \textit{Specify the format of all system inputs}, poiché ogni input viene verificato prima dell’elaborazione.
                    \item \textbf{Crittografia per dati sensibili}: uso di algoritmi aggiornati per proteggere informazioni riservate di sistema e utenti. La cifratura rende i dati illeggibili senza le chiavi corrette, tutela la privacy e favorisce la conformità al GDPR.
                    \item \textbf{Limitare tentativi di log‑in (Rate limiter)}: introdotta una soglia ai tentativi in una finestra temporale per mitigare attacchi di Brute Force, abbassando drasticamente la probabilità di successo e l’esposizione del sistema.
                    \item \textbf{Politiche di password robuste}: richieste credenziali complesse, come l'utilizzo di lettere maiuscole e minuscole, numeri, simboli ed una lunghezza minima per ostacolare furti di account e forza bruta, riducendo gli accessi non autorizzati.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modellazione tramite Catena di Markov}

Le catene di Markov sono modelli matematici utilizzati per descrivere sistemi che evolvono nel tempo in modo stocastico, cioè in modo probabilistico, basandosi sul principio di Markov, secondo cui il futuro stato del sistema dipende solo dallo stato attuale e non dalla storia passata, ma solo dall'ultima osservazione. Nel nostro caso, le catene di Markov sono state utilizzate per modellare il comportamento della funzione di login e di un attaccante, rappresentando i vari stati in cui essi possono trovarsi e le transizioni tra gli stati, descritte da funzioni di probabilità di transizione.

\subsection{Catena di Markov per la funzione di login}

È stato deciso di modellare la funzione di login del sistema mediante una catena di Markov, al fine di analizzare il comportamento degli utenti durante il processo di autenticazione, fondamentale nei sistemi informatici. La catena di Markov per la funzione di login è composta da 20 stati e 7 contatori:

\begin{itemize}
    \item \textbf{$C_{LOG}$}: contatore dei tentativi di login (inserimento username e password);
    \item \textbf{$C_{RPASS}$}: contatore d'inserimento del codice per il recupero della password;
    \item \textbf{$C_{MFA}$}: contatore dei tentativi d'inserimento del codice MFA;
    \item \textbf{$C_{EMAIL}$}: contatore dell'inserimento delle email nel campo recupero password;
    \item \textbf{$C_{RinvioMFA}$}: contatore per tenere traccia di quante volte è stato effettuato il rinvio del codice MFA;
    \item \textbf{$C_{RinvioRPASS}$}: contatore per tenere traccia di quante volte è stato effettuato il rinvio del codice di recupero password;
    \item \textbf{$C_{NuovaPass}$}: contatore dei tentativi d'inserimento della nuova password.
\end{itemize}

Lo stato iniziale della catena di Markov è lo stato \textbf{0}, che rappresenta l'utente che apre la schermata di login. Qui si ha la prima biforcazione, se l'utente sceglie di recuperare la propria password, si passa allo stato \textbf{9} tramite la transizione etichettata con \textit{/PasswordDimenticata}, altrimenti si passa allo stato \textbf{1} con etichetta \textit{/Login} se l'utente decide di fare il login. 

Vediamo la transizione che riguarda l'inserimento dei dati di login: dallo stato \textbf{1}, dopo l'inserimento dell'email si passa allo stato \textbf{2} e dopo l'inserimento della password si transita allo stato \textbf{3}, inoltre viene decrementato il counter dei tentativi $C_{LOG}$ di 1, ciò rappresenta l'effettuazione di un tentativo di login. Se le credenziali sono corrette, si passa allo stato \textbf{5} tramite la transizione etichettata con \textit{?DatiOK}, altrimenti, se le credenziali sono sbagliate si passa allo stato \textbf{4}, il quale rappresenta uno stato intermedio. In quest ultimo stato, se il contatore $C_{LOG}$ è maggiore di 0, si torna allo stato \textbf{1}; se il contatore è uguale a 0, vuol dire che sono esauriti i tentativi di login e si va nello stato \textbf{20}, il quale rappresenta uno stato di timeout dopo un certo numero di azioni e si rimane in questo stato indefinitamente tramite la transizione \textit{?Timeout}. 
Per quanto riguarda lo stato \textbf{5}, esso rappresenta la decisione da parte dell'utente d'inserire il codice MFA oppure di farselo rinviare. Se decide d'inserire il codice MFA, il contatore $C_{MFA}$ viene decrementato di 1 e si fa una transizione nello stato \textbf{7}. Se il codice è corretto, si passa allo stato \textbf{9} tramite la transizione etichettata con \textit{?CodiceMFAOK}, questo rappresenta lo stato con cui il login è avvenuto con successo e vi si rimane indefinitamente (l'etichetta è \textit{?LoginEffettuato}). Se il codice MFA è errato, sia passa allo stato \textbf{8}; se il contatore $C_{MFA}$ è maggiore di 0, cioè ci sono ancora tentativi a disposizione per inserire il codice MFA, si torna allo stato \textbf{5} e viene chiesto nuovamente all'utente d'inserire il codice MFA o di fare il rinvio di quest'ultimo; se il contatore è uguale a 0, si va nello stato \textbf{20} e, come detto precedentemente, esso rappresenta lo stato di timeout. Infine, vi è un'ulteriore transizione etichettata \textit{/RinvioCodiceMFA}, che permette all'utente di farsi rinviare il codice MFA, andando a finire nello stato \textbf{6}; se il contatore $C_{RinvioMFA}$ è maggiore di 0, si ritorna nello stato \textbf{5}, altrimenti se il contatore è uguale a 0 si va nello stato di timeout \textbf{20}; queste transizioni rappresentano una limitazione nell'invio da parte del sistema dei codici MFA.

Se l'utente sceglie di effettuare il recupero della propria password, si passa allo stato \textbf{10} con la transizione \textit{/PasswordDimenticata}. Qui, dopo che l'utente ha inserito l'email su cui effettuare il recupero della password, viene decrementato il contatore $C_{EMAIL}$ di 1 e si passa allo stato \textbf{11}. Qui il sistema controlla se l'email è presente nel database. Se l'email non esiste, si va a finire con la transizione \textit{?EmailKO} nello stato \textbf{12}, in cui se il contatore $C_{EMAIL}$ è maggiore di 0, si torna allo stato \textbf{10} e viene chiesto nuovamente all'utente d'inserire un'email valida, altrimenti se il contatore è uguale a 0, si va nello stato di timeout. Invece, se l'email è corretta, si passa allo stato \textbf{13} tramite la transizione etichettata con \textit{?EmailOK}. In questo stato, il sistema invia una email all'utente con un codice per reimpostare la password; a questo punto l'utente deve decidere se inserire il codice ricevuto, decrementando il contatore $C_{RPASS}$ di 1 e transitando allo stato \textbf{15} con l'etichetta \textit{/InserimentoCodice} oppure se farsi rinviare il codice di recupero password. Se l'utente decide l'ultima opzione ed il contatore $C_{RinvioRPASS}$ è maggiore di 0, si torna nello stato \textbf{13}, altrimenti se il contatore è uguale a 0, si va nello stato di timeout.

Se il codice di recupero password inserito è errato si passa allo stato \textbf{16} con la transizione \textit{?CodiceKO} e tramite il contatore $C_{RPASS}$ il sistema decide se far ritentare l'inserimento o andare il timeout. Invece, se il codice è corretto, si passa dallo stato \textbf{15} allo stato \textbf{17} tramite la transizione etichettata con \textit{?CodiceOK}. In questo stato si chiede all'utente d'inserire una nuova password. Dopo averla inserita si transita nello stato \textbf{18} con etichetta \textit{/!InserimentoNuovaPassword} e viene decrementato il contatore $C_{NuovaPass}$; se la password soddisfa i criteri richiesti dal sistema, si transita allo stato \textbf{0} tramite l'etichetta \textit{?NuovaPasswordOK}; in questa fase i contatori delle varie azioni sono resettati al limite massimo e l'utente può iniziare nuovamente la fase di login. Invece, se la nuova password non soddisfa i criteri richiesti, si transita nello stato \textbf{19} tramite la transizione etichettata con \textit{?NuovaPasswordKO}; come in precedenza, se il contatore $C_{NuovaPass}$ è maggiore di 0, si torna allo stato \textbf{17} e viene chiesto nuovamente all'utente d'inserire una nuova password; se il contatore è uguale a 0, si va nello stato di timeout \textbf{20}.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/catenaDiMarkovLogin.png}
\end{figure}

\FloatBarrier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Catena di Markov per l'attaccante}
Come per la catena di Markov precedente, sono stati usati dei contatori per tenere traccia dei tentativi effettuati dall'attaccante. Essi rappresentano la grandezza del dizionario usato per l'attacco di forza bruta. I contatori sono i seguenti:

\begin{itemize}
    \item \textbf{$n_{email}$}: contatore che rappresenta la grandezza del dizionario delle email usate per l'attacco di forza bruta;
    \item \textbf{$n_{pass}$}: contatore che rappresenta la grandezza del dizionario delle password usate per l'attacco di forza bruta;
    \item \textbf{$tentativo_{email}$}: contatore che tiene traccia dei tentativi d'inserimento dell'email effettuati dall'attaccante;
    \item \textbf{$tentativo_{pass}$}: contatore che tiene traccia dei tentativi d'inserimento della password effettuati dall'attaccante;
    \item \textbf{$tentativo_{codice\_pass}$}: contatore che tiene traccia dei tentativi d'inserimento del codice di recupero password effettuati dall'attaccante;
    \item \textbf{$tentativo_{mfa}$}: contatore che tiene traccia dei tentativi d'inserimento del codice MFA effettuati dall'attaccante.
    \item \textbf{$tentativo_{rinvio\_mfa}$}: contatore che tiene traccia dei tentativi di rinvio del codice MFA effettuati dall'attaccante.
    \item \textbf{$tentativo_{rinvio\_codice\_pass}$}: contatore che tiene traccia dei tentativi di rinvio del codice di recupero password effettuati dall'attaccante.
    \item \textbf{$tentativo_{nuova\_pass}$}: contatore che tiene traccia dei tentativi d'inserimento della nuova password effettuati dall'attaccante.
\end{itemize}

Lo stato iniziale è lo stato \textbf{0} e vi sono due possibilità. Se l'attaccante decide di attaccare la funzione di login, si passa allo stato \textbf{1} tramite la transizione etichettata con \textit{/!InizioAttaccoLogin}, altrimenti si passa allo stato \textbf{14} con etichetta \textit{/!InizioAttaccoPasswordDimenticata} se l'attaccante decide di attaccare la funzione di recupero password. Le probabilità di transitare da uno stato all'altro sono state scelte arbitrariamente in modo da poter simulare entrambi gli scenari equamente.

Andando ad analizzare l'attacco di forza bruta sulla funzione di login, si passa dallo stato \textbf{1} allo stato \textbf{2} con la transizione etichettata \textit{/!InserisciEmail} e successivamente si transita allo stato \textbf{3} con l'etichetta \textit{/!InserisciPassword}. In entrambe le transizioni si decrementano rispettivamente i due contatori $tentativo_{email}$ e $tentativo_{pass}$. Questo rappresenta l'inserimento delle credenziali da parte dell'attaccante. In seguito, si passa o allo stato \textbf{4} o al \textbf{5} con l'etichetta \textit{?CheckDati}, che rappresenta l'invio delle credenziali al sistema. A queste due transizioni sono collegate due probabilità: $P_{login\_success}$, che rappresenta la probabilità d'indovinare le credenziali e $P_{login\_fail}$, che corrisponde alla probabilità complementare, quindi di sbagliare le credenziali. Se le credenziali sono errate, si passa allo stato \textbf{6} tramite la transizione etichettata con \textit{?DatiKO}.
Qui bisogna distinguere 3 casi: nel primo caso, se i contatori $tentativo_{email}$ e $tentativo_{pass}$ sono uguali a 0, si va allo stato \textbf{24}, cioè uno stato che rappresenta il fallimento dell'attacco perché sono finite le combinazioni di email e password; nel secondo caso, se il contatore $tentativo_{pass}$ è maggiore di 0, allora si torna allo stato \textbf{2}, cioè l'attaccante deve riprovare altre password con la stessa email che stava provando in precedenza; nel terzo caso, se il contatore $tentativo_{email}$ è maggiore di 0 e $tentativo_{pass}$ è uguale a 0, allora si resetta il numero di tentativi delle password, cioè $tentativo_{pass}$ e si torna allo stato \textbf{1}, cioè l'attaccante deve riprovare tutte le password con un'altra email.

Se l'attaccante è riuscito ad indovinare le credenziali, dallo stato \textbf{3} si passa allo stato \textbf{4}. Successivamente, si transita allo stato \textbf{7} con l'etichetta \textit{?DatiOK}. Dallo stato \textbf{7} ci sono due possibilità; se l'attaccante decide di inserire il codice MFA si transita allo stato \textbf{8} con l'etichetta \textit{/!InserimentoCodiceMFA} e si decrementa il contatore $tentativo_{mfa}$. Come nel caso precedente, in base a delle probabilità, l'attaccante potrebbe indovinare il codice MFA; se il codice MFA è corretto, si passa allo stato \textbf{10} con l'etichetta \textit{?CheckMFA}. Dopodiché, si passa allo stato \textbf{12} con la transizione \textit{/!CodiceMFAOK} e, infine, Si transita a llo stato \textbf{13} con l'etichetta \textit{?AttaccoRiuscito}, concludendo l'attacco con successo. Altrimenti, se il codice MFA è errato, si passa allo stato \textbf{9} tramite la stessa transizione. Qui, si transita allo stato \textbf{11} con l'etichetta \textit{/!CodiceMFAKO}. Successivamente, se il contatore $tentativo_{mfa}$ è maggiore di 0, si torna allo stato \textbf{7}, altrimenti se il contatore è uguale a 0, si va nello stato \textbf{24}, cioè lo stato di fallimento dell'attacco.

Se l'attaccante ha deciso di effettuare un attacco sulla funzione di recupero password, si passa dallo stato \textbf{0} allo stato \textbf{14}. Successivamente, con l'etichetta \textit{/!inserimentoEmail} si passa allo stato \textbf{15} e si decrementa il contatore $tentativo_{email}$. Qui, come nei casi precedenti, in base a delle probabilità, l'attaccante potrebbe indovinare una email valida. Se l'email inserita è corretta, si passa allo stato \textbf{16} con l'etichetta \textit{?CheckEmail} e poi allo stato \textbf{19} con l'etichetta \textit{?EmailOK}, altrimenti si passa allo stato \textbf{17} tramite la transizione etichettata con \textit{?CheckEmail} e poi si va nello stato \textbf{18} con la transizione \textit{?EmailKO}. Qui bisogna distinguere 2 casi: se il contatore $tentativo_{email}$ è uguale a 0, si va allo stato \textbf{24}, cioè lo stato di fallimento dell'attacco; altrimenti, se il contatore è maggiore di 0, si torna allo stato \textbf{14}, cioè l'attaccante deve riprovare con un'altra email. 

In caso di successo nell'inserimento di una email valida, è richiesto un codice di recupero password. Quindi, dallo stato \textbf{19} ci sono due possibilità. Se l'attaccante decide di far rinviare il codice di recupero password, si va nello stato \textbf{25} con l'etichetta \textit{/RinvioCodicePass}, decrementando il contatore $tentativo_{rinvio\_codice\_pass}$. Poi, se il contatore $tentativo_{rinvio\_codice\_pass}$ è maggiore di 0, si torna allo stato \textbf{19}, altrimenti se è = 0 si passa allo stato \textbf{24}. Invece, se l'attaccante decide d'inserire il codice di recupero password, si passa allo stato \textbf{20} con la transizione \textit{/!InserimentoCodicePass} e si decrementa il contatore $tentativo_{codice\_pass}$. Anche qui, tramite una probabilità si decide se l'attaccante ha indovinato o no il codice di recupero password. Se il codice di recupero password inserito è sbagliato, si passa allo stato \textbf{21} tramite la transizione etichettata con \textit{?CheckCodicePass} e da esso si transita nello stato \textbf{22}. Qui si vede il contatore $tentativo_{codice\_pass}$, se è maggiore di 0 si torna nello stato \textbf{19}, altrimenti si va nello stato di attacco fallito. Invece, se il codice inserito è corretto, si passa allo stato \textbf{23} con la stessa transizione \textit{?CheckCodicePass}. Dopodiché, si transita nello stato \textbf{27} con l'etichetta \textit{?CodicePassOK}, dove l'attaccante deve inserire una nuova password. Dopo l'inserimento, si passa allo stato \textbf{28} con l'etichetta \textit{/!InserimentoNuovaPassword} e si decrementa il contatore $tentativo_{nuova\_pass}$. Tramite una certa probabilità, se la nuova password soddisfa i criteri richiesti dal sistema, si transita allo stato \textbf{29} tramite l'etichetta \textit{?CheckNuovaPassword}; in questo caso si torna allo stato \textbf{0} con la transizione \textit{?NuovaPasswordOK}, così l'attaccante può effettuare il login con le credenziali appena ottenute. Altrimenti, se la nuova password non soddisfa i criteri richiesti, si transita nello stato \textbf{30} tramite la transizione etichettata con \textit{?CheckNuovaPassword} e poi si va nello stato \textbf{31} con la transizione \textit{?NuovaPasswordKO}; come in precedenza, se il contatore $tentativo_{nuova\_pass}$ è maggiore di 0, si torna allo stato \textbf{27} e l'attaccante deve riprovare ad inserire una nuova password; se il contatore è uguale a 0, si va nello stato \textbf{24}, cioè lo stato di fallimento dell'attacco.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=1\columnwidth]{chapter3/immagini/catenaDiMarkovAttaccante.png}
\end{figure}

\FloatBarrier

\subsection{Modellazione tramite PRISM}

Per analizzare la catena di Markov della funzione di login e dell'attaccante, è stato utilizzato il tool PRISM, un software per la modellazione e l'analisi di sistemi stocastici. PRISM consente di definire modelli formali, come le catene di Markov, e di eseguire analisi quantitative su di essi. Il modello formale usato per modellare la funzione di login è una \textbf{Discrete-Time Markov Chain (DTMC)}, che rappresenta un sistema che evolve nel tempo in modo discreto, con transizioni tra stati che avvengono in modo probabilistico. Ciò permette anche l'analisi di proprietà che il sistema dovrebbe soddisfare. Inoltre, PRISM esegue automaticamente la composizione dei vari moduli che compongono il modello finale, permettendo di definire modelli complessi ed effettuare simulazioni su di esso. Per sincronizzare i due moduli, sono state usate etichette uguali per le transizioni che necessitano di sincronizzazione tra i moduli.

\subsubsection{Codice PRISM della composizione delle catene di Markov}
Di seguito è riportato il codice PRISM utilizzato per il modello:
\vspace{1cm}

%%%%%%%%%%%%%%%% MODELLO PRISM %%%%%%%%%%%%%%%%%
\begin{highlightPrism}
\hfuzz=35pt

\keyword{\hspace{0.6em}dtmc}
\\\\
\cmt{// VARIABILI ATTACCANTE}
\\
\keyword{const} \keyword{int} \variable{n\_pass} = \numberb{6};
\\
\keyword{const} \keyword{int} \variable{n\_email} = \numberb{6};
\\
\keyword{const} \keyword{int} \variable{n\_codici} = \numberb{10};
\\
\keyword{const} \keyword{int} \variable{n\_codici\_pass} = \numberb{10};
\\\\
\cmt{// ETICHETTE DEGLI STATI}
\\
\keyword{label} \texttt{"\variable{AttaccoRiuscito}"} =
(\variable{statoAtt} = \numberb{13});
\\
\keyword{label} \texttt{"\variable{AttaccoFallito}"} =
(\variable{statoAtt} = \numberb{24});
\\
\keyword{label} \texttt{"\variable{LoginEffettuato}"} =
(\variable{statoLogin} = \numberb{9});
\\
\keyword{label} \texttt{"\variable{Timeout}"} =
(\variable{statoLogin} = \numberb{20});
\\\\
\cmt{// PROBABILITA'}
\\
\keyword{const} \keyword{double} \variable{p\_login\_success} =
\numberb{0.01};
\\
\keyword{const} \keyword{double} \variable{p\_login\_fail} =
\numberb{1} - \variable{p\_login\_success};
\\\\
\keyword{const} \keyword{double} \variable{p\_mfa\_success} =
\numberb{0.01};
\\
\keyword{const} \keyword{double} \variable{p\_mfa\_fail} =
\numberb{1} - \variable{p\_mfa\_success};
\\\\
\keyword{const} \keyword{double} \variable{p\_email\_reset\_success} =
\numberb{0.05};
\\
\keyword{const} \keyword{double} \variable{p\_email\_reset\_fail} =
\numberb{1} - \variable{p\_email\_reset\_success};
\\\\
\keyword{const} \keyword{double} \variable{p\_codice\_email\_success} =
\numberb{0.01};
\\
\keyword{const} \keyword{double} \variable{p\_codice\_email\_fail} =
\numberb{1} - \variable{p\_codice\_email\_success};
\\\\
\keyword{const} \keyword{double} \variable{p\_nuova\_pass\_success} =
\numberb{0.01};
\\
\keyword{const} \keyword{double} \variable{p\_nuova\_pass\_fail} =
\numberb{1} - \variable{p\_nuova\_pass\_success};
\\\\
\keyword{const} \keyword{int} \variable{numTentativi} =
\numberb{5};
\\\\
\cmt{/////////////// MODULO LOGIN //////////////////}
\\\\
\keyword{module} \variable{login\_function}
\\\\
\cmt{//// VARIABILI LOGIN ////////}
\\
\variable{statoLogin} :
[\numberb{0}..\numberb{20}] \keyword{init} \numberb{0};
\\
\variable{c\_log} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_mfa} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_rpass} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_email} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_rinvioMFA} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_rinvioRPASS} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{c\_nuovaPass} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\\\
\cmt{//uscenti da stato 0}
\\
[\variable{inizioAttaccoLogin}]
(\variable{statoLogin}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{1});
\\
[\variable{inizioAttaccoPasswordDimenticata}]
(\variable{statoLogin}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{10});
\\\\
\cmt{////////////////////}
\\
\cmt{////// LOGIN ///////}
\\
\cmt{////////////////////}
\\\\
[\variable{InserimentoEmail}]
(\variable{statoLogin}=\numberb{1})
-> (\variable{statoLogin}'=\numberb{2});
\\\\
[\variable{InserimentoPassword}]
(\variable{statoLogin}=\numberb{2})
\& (\variable{c\_log} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{3})
\& \\ (\variable{c\_log}'
=\variable{c\_log}-\numberb{1});
\\\\
[\variable{DatiOK}]
(\variable{statoLogin}=\numberb{3})
-> (\variable{statoLogin}'=\numberb{5});
\\
[\variable{DatiKO}]
(\variable{statoLogin}=\numberb{3})
-> (\variable{statoLogin}'=\numberb{4});
\\\\
[\variable{RitentaDati}]
(\variable{statoLogin}=\numberb{4})
\& (\variable{c\_log} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{1});
\\
[\variable{RitentaPassword}]
(\variable{statoLogin}=\numberb{4})
\& (\variable{c\_log} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{2});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{4})
\& (\variable{c\_log}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
[\variable{InserimentoMFA}]
(\variable{statoLogin}=\numberb{5})
\& (\variable{c\_mfa} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{7})
\& \\ (\variable{c\_mfa}'
=\variable{c\_mfa}-\numberb{1});
\\
[\variable{RinvioCodiceMFA}]
(\variable{statoLogin}=\numberb{5})
\& (\variable{c\_rinvioMFA} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{6})
\& (\variable{c\_rinvioMFA}'
=\variable{c\_rinvioMFA}-\numberb{1});
\\\\
[\variable{MFARinviato}]
(\variable{statoLogin}=\numberb{6})
\& (\variable{c\_rinvioMFA} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{5});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{6})
\& (\variable{c\_rinvioMFA}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
[\variable{CodiceMFAOK}]
(\variable{statoLogin}=\numberb{7})
-> (\variable{statoLogin}'=\numberb{9});
\\
[\variable{CodiceMFAKO}]
(\variable{statoLogin}=\numberb{7})
-> (\variable{statoLogin}'=\numberb{8});
\\\\
[\variable{RitentaCodiceMFA}]
(\variable{statoLogin}=\numberb{8})
\& (\variable{c\_mfa} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{5});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{8})
\& (\variable{c\_mfa}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
\cmt{////////////////////////////////}
\\
\cmt{////// RECUPERO PASSWORD ///////}
\\
\cmt{////////////////////////////////}
\\\\
[\variable{InserimentoEmail}]
(\variable{statoLogin}=\numberb{10})
\& (\variable{c\_email} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{11})
\& \\ (\variable{c\_email}'
=\variable{c\_email}-\numberb{1});
\\\\
[\variable{EmailKO}]
(\variable{statoLogin}=\numberb{11})
-> (\variable{statoLogin}'=\numberb{12});
\\
[\variable{EmailOK}]
(\variable{statoLogin}=\numberb{11})
-> (\variable{statoLogin}'=\numberb{13});
\\\\
[\variable{RitentaEmail}]
(\variable{statoLogin}=\numberb{12})
\& (\variable{c\_email} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{10});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{12})
\& (\variable{c\_email}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
[\variable{InserimentoCodicePass}]
(\variable{statoLogin}=\numberb{13})
\& (\variable{c\_rpass} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{15})
\& (\variable{c\_rpass}'
=\variable{c\_rpass}-\numberb{1});
\\
[\variable{RinvioCodicePass}]
(\variable{statoLogin}=\numberb{13})
\& (\variable{c\_rinvioRPASS} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{14})
\& (\variable{c\_rinvioRPASS}'
=\variable{c\_rinvioRPASS}-\numberb{1});
\\\\
[\variable{CodiceRecuperoPassRinviato}]
(\variable{statoLogin}=\numberb{14})
\& (\variable{c\_rinvioRPASS} > \numberb{0})
-> \\ (\variable{statoLogin}'=\numberb{13});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{14})
\& (\variable{c\_rinvioRPASS}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
[\variable{CodicePassKO}]
(\variable{statoLogin}=\numberb{15})
-> (\variable{statoLogin}'=\numberb{16});
\\
[\variable{CodicePassOK}]
(\variable{statoLogin}=\numberb{15})
-> (\variable{statoLogin}'=\numberb{17});
\\\\
[\variable{RitentaCodicePassword}]
(\variable{statoLogin}=\numberb{16})
\& (\variable{c\_rpass} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{13});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{16})
\& (\variable{c\_rpass}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
[\variable{InserimentoNuovaPassword}]
(\variable{statoLogin}=\numberb{17})
\& (\variable{c\_nuovaPass} > \numberb{0})
-> \\ (\variable{statoLogin}'=\numberb{18})
\& (\variable{c\_nuovaPass}'
=\variable{c\_nuovaPass}-\numberb{1});
\\\\
[\variable{NuovaPasswordKO}]
(\variable{statoLogin}=\numberb{18})
-> (\variable{statoLogin}'=\numberb{19});
\\
[\variable{NuovaPasswordOK}]
(\variable{statoLogin}=\numberb{18})
-> (\variable{statoLogin}'=\numberb{0})
\& (\variable{c\_log}'=\variable{numTentativi})\\
\& (\variable{c\_mfa}'=\variable{numTentativi})
\& (\variable{c\_rpass}'=\variable{numTentativi})
\& (\variable{c\_email}'=\variable{numTentativi})\\
\& (\variable{c\_rinvioMFA}'=\variable{numTentativi})
\& (\variable{c\_rinvioRPASS}'=\variable{numTentativi})
\& \\ (\variable{c\_nuovaPass}'=\variable{numTentativi});
\\\\
[\variable{RitentaNuovaPassword}]
(\variable{statoLogin}=\numberb{19})
\& (\variable{c\_nuovaPass} > \numberb{0})
-> (\variable{statoLogin}'=\numberb{17});
\\
[\variable{Timeout}]
(\variable{statoLogin}=\numberb{19})
\& (\variable{c\_nuovaPass}=\numberb{0})
-> (\variable{statoLogin}'=\numberb{20});
\\\\
\keyword{endmodule}
\\\\
\cmt{///////////////////// MODULO ATTACCANTE ////////////////////////}
\\\\
\keyword{module} \variable{attacker}
\\\\
\variable{statoAtt} : [\numberb{0}..\numberb{31}] \keyword{init} \numberb{0};
\\
\variable{tentativo\_email} :
[\numberb{0}..\variable{n\_email}] \keyword{init} \variable{n\_email};
\\
\variable{tentativo\_pass} :
[\numberb{0}..\variable{n\_pass}] \keyword{init} \variable{n\_pass};
\\
\variable{tentativo\_mfa} :
[\numberb{0}..\variable{n\_codici}] \keyword{init} \variable{n\_codici};
\\
\variable{tentativo\_codice\_pass} :
[\numberb{0}..\variable{n\_codici\_pass}]
\keyword{init} \variable{n\_codici\_pass};
\\
\variable{tentativo\_rinvioMFA} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{tentativo\_rinvio\_codice\_pass} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\
\variable{tentativo\_nuova\_pass} :
[\numberb{0}..\variable{numTentativi}]
\keyword{init} \variable{numTentativi};
\\\\
\cmt{//////////////////////////////////////////////////////}
\\
\cmt{//////////////// LOGIN ATTACCANTE ////////////////////}
\\
\cmt{//////////////////////////////////////////////////////}
\\\\
\cmt{//uscenti da 0}
\\
[\variable{inizioAttaccoLogin}]
\variable{statoAtt}=\numberb{0}
-> (\variable{statoAtt}'=\numberb{1});
\\
[\variable{inizioAttaccoPasswordDimenticata}]
\variable{statoAtt}=\numberb{0}
-> (\variable{statoAtt}'=\numberb{14});
\\\\
[\variable{InserimentoEmail}]
(\variable{statoAtt}=\numberb{1})
\& (\variable{tentativo\_email} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{2})
\& \\ (\variable{tentativo\_email}'
=\variable{tentativo\_email}-\numberb{1});
\\\\
[\variable{InserimentoPassword}]
(\variable{statoAtt}=\numberb{2})
\& (\variable{tentativo\_pass} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{3})\\
\& (\variable{tentativo\_pass}'
=\variable{tentativo\_pass}-\numberb{1});
\\\\
[\variable{CheckDati}]
\variable{statoAtt}=\numberb{3}
-> \variable{p\_login\_success} :
(\variable{statoAtt}'=\numberb{4})
+ \variable{p\_login\_fail} :\\
(\variable{statoAtt}'=\numberb{5});
\\\\
[\variable{DatiOK}]
\variable{statoAtt}=\numberb{4}
-> (\variable{statoAtt}'=\numberb{7});
\\
[\variable{DatiKO}]
\variable{statoAtt}=\numberb{5}
-> (\variable{statoAtt}'=\numberb{6});
\\\\
[\variable{RitentaPassword}]
(\variable{statoAtt}=\numberb{6})
\& (\variable{tentativo\_pass} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{2});
\\\\
[\variable{RitentaDati}]
(\variable{statoAtt}=\numberb{6})
\& (\variable{tentativo\_pass}=\numberb{0})
\& (\variable{tentativo\_email} > \numberb{0})
-> \\(\variable{statoAtt}'=\numberb{1})
\& (\variable{tentativo\_pass}'=\variable{n\_pass});
\\\\
[\variable{AttaccoFallito}]
(\variable{statoAtt}=\numberb{6})
\& (\variable{tentativo\_pass}=\numberb{0})
\& (\variable{tentativo\_email}=\numberb{0})
-> \\(\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{6})
\& (\variable{c\_log}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{RinvioCodiceMFA}]
(\variable{statoAtt}=\numberb{7})
\& (\variable{tentativo\_rinvioMFA} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{26})\\
\& (\variable{tentativo\_rinvioMFA}'
=\variable{tentativo\_rinvioMFA}-\numberb{1});
\\\\
[\variable{MFARinviato}]
(\variable{statoAtt}=\numberb{26})
\& (\variable{tentativo\_rinvioMFA} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{7});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{26})
\& (\variable{tentativo\_rinvioMFA}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{InserimentoMFA}]
(\variable{statoAtt}=\numberb{7})
\& (\variable{tentativo\_mfa} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{8})
\& \\(\variable{tentativo\_mfa}'
=\variable{tentativo\_mfa}-\numberb{1});
\\\\
[\variable{CheckMFA}]
(\variable{statoAtt}=\numberb{8})
-> \variable{p\_mfa\_success} :
(\variable{statoAtt}'=\numberb{10})
+ \variable{p\_mfa\_fail} :\\
(\variable{statoAtt}'=\numberb{9});
\\\\
[\variable{CodiceMFAOK}]
\variable{statoAtt}=\numberb{10}
-> (\variable{statoAtt}'=\numberb{12});
\\
[\variable{CodiceMFAKO}]
\variable{statoAtt}=\numberb{9}
-> (\variable{statoAtt}'=\numberb{11});
\\\\
[\variable{RitentaCodiceMFA}]
(\variable{statoAtt}=\numberb{11})
\& (\variable{tentativo\_mfa} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{7});
\\\\
[\variable{AttaccoFallito}]
(\variable{statoAtt}=\numberb{11})
\& (\variable{tentativo\_mfa}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{11})
\& (\variable{c\_mfa}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{AttaccoRiuscito}]
(\variable{statoAtt}=\numberb{12})
-> (\variable{statoAtt}'=\numberb{13});
\\\\
\cmt{//////////////////////////////////////////////////////}
\\
\cmt{//////// PASSWORD DIMENTICATA ATTACCANTE /////////////}
\\
\cmt{//////////////////////////////////////////////////////}
\\\\
[\variable{InserimentoEmail}]
(\variable{statoAtt}=\numberb{14})
\& (\variable{tentativo\_email} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{15})
\& (\variable{tentativo\_email}'
=\variable{tentativo\_email}-\numberb{1});
\\\\
[\variable{CheckEmail}]
\variable{statoAtt}=\numberb{15}
-> \variable{p\_email\_reset\_success} :
(\variable{statoAtt}'=\numberb{16})
+ \\ \variable{p\_email\_reset\_fail} :
(\variable{statoAtt}'=\numberb{17});
\\\\
[\variable{EmailKO}]
\variable{statoAtt}=\numberb{17}
-> (\variable{statoAtt}'=\numberb{18});
\\
[\variable{EmailOK}]
\variable{statoAtt}=\numberb{16}
-> (\variable{statoAtt}'=\numberb{19});
\\\\
[\variable{RitentaEmail}]
(\variable{statoAtt}=\numberb{18})
\& (\variable{tentativo\_email} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{14});
\\\\
[\variable{AttaccoFallito}]
(\variable{statoAtt}=\numberb{18})
\& (\variable{tentativo\_email}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{18})
\& (\variable{c\_email}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{InserimentoCodicePass}]
(\variable{statoAtt}=\numberb{19})
\& (\variable{tentativo\_codice\_pass} > \numberb{0})
-> \\ (\variable{statoAtt}'=\numberb{20})
\& (\variable{tentativo\_codice\_pass}'
=\variable{tentativo\_codice\_pass}-\numberb{1});
\\\\
[\variable{CheckCodicePass}]
(\variable{statoAtt}=\numberb{20})
-> \variable{p\_codice\_email\_success} :
(\variable{statoAtt}'=\numberb{23})
+ \variable{p\_codice\_email\_fail} :
(\variable{statoAtt}'=\numberb{21});
\\\\
[\variable{CodicePassOK}]
\variable{statoAtt}=\numberb{23}
-> (\variable{statoAtt}'=\numberb{27});
\\
[\variable{CodicePassKO}]
\variable{statoAtt}=\numberb{21}
-> (\variable{statoAtt}'=\numberb{22});
\\\\
[\variable{RinvioCodicePass}]
(\variable{statoAtt}=\numberb{19})
\& (\variable{tentativo\_rinvio\_codice\_pass} > \numberb{0})
-> \\ (\variable{statoAtt}'=\numberb{25})
\& (\variable{tentativo\_rinvio\_codice\_pass}'
=\variable{tentativo\_rinvio\_codice\_pass}-\numberb{1});
\\\\
[\variable{CodiceRecuperoPassRinviato}]
(\variable{statoAtt}=\numberb{25})
\& (\variable{tentativo\_rinvio\_codice\_pass} > \numberb{0})
-> (\variable{statoAtt}'=\numberb{19});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{25})
\& (\variable{c\_rinvioRPASS}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{RitentaCodicePassword}]
(\variable{statoAtt}=\numberb{22})
\& (\variable{tentativo\_codice\_pass} > \numberb{0})
-> \\ (\variable{statoAtt}'=\numberb{19});
\\\\
[\variable{AttaccoFallito}]
(\variable{statoAtt}=\numberb{22})
\& (\variable{tentativo\_codice\_pass}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{22})
\& (\variable{c\_rpass}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{24});
\\\\
[\variable{InserimentoNuovaPassword}]
(\variable{statoAtt}=\numberb{27})
\& (\variable{tentativo\_nuova\_pass} > \numberb{0})
-> \\ (\variable{statoAtt}'=\numberb{28})
\& (\variable{tentativo\_nuova\_pass}'
=\variable{tentativo\_nuova\_pass}-\numberb{1});
\\\\
[\variable{CheckNuovaPass}]
(\variable{statoAtt}=\numberb{28})
-> \variable{p\_nuova\_pass\_success} :
(\variable{statoAtt}'=\numberb{29})
+ \\ \variable{p\_nuova\_pass\_fail} :
(\variable{statoAtt}'=\numberb{30});
\\\\
[\variable{NuovaPasswordKO}]
\variable{statoAtt}=\numberb{30}
-> (\variable{statoAtt}'=\numberb{31});
\\\\
[\variable{RitentaNuovaPassword}]
(\variable{statoAtt}=\numberb{31})
\& (\variable{tentativo\_nuova\_pass} > \numberb{0})
-> \\ (\variable{statoAtt}'=\numberb{27});
\\\\
[\variable{AttaccoFallito}]
(\variable{statoAtt}=\numberb{31})
\& (\variable{tentativo\_nuova\_pass}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{27});
\\\\
[\variable{Timeout}]
(\variable{statoAtt}=\numberb{31})
\& (\variable{c\_nuovaPass}=\numberb{0})
-> (\variable{statoAtt}'=\numberb{27});
\\\\
[\variable{NuovaPasswordOK}]
(\variable{statoAtt}=\numberb{29})
-> (\variable{statoAtt}'=\numberb{0})
\& (\variable{tentativo\_codice\_pass}'\\
=\variable{n\_codici\_pass})
\& (\variable{tentativo\_rinvio\_codice\_pass}'
=\variable{numTentativi})
\& \\ (\variable{tentativo\_nuova\_pass}'
=\variable{numTentativi})
\& (\variable{tentativo\_email}'
=\variable{numTentativi});
\\\\
\keyword{endmodule}

\end{highlightPrism}

\clearpage

%%%%%%%%%%%%% SIMULAZIONI %%%%%%%%%%%%%%%%
\subsection{Simulazioni tramite PRISM}

Sfruttando il simulatore di PRISM, sono state eseguite delle simulazioni per analizzare il comportamento del sistema in diversi scenari. Di seguito sono riportate alcune simulazioni:

\subsubsection{Simulazione attacco login con successo}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_attacco_login_con_successo.png}
    \caption{Utente che riesce ad attaccare la funzione di login con successo, ottenendo l'accesso ad un account.}
\end{figure}

La figura 3.1 mostra la simulazione di un utente che effettua un attacco di forza bruta con dizionario sulla funzione di login. Esso riesce a indovinare correttamente sia le credenziali di accesso (email e password) sia il codice MFA, ottenendo così l'accesso ad un account.

\FloatBarrier

\clearpage

\subsubsection{Simulazione attacco login fallito per timeout}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_attacco_login_fallito.png}
    \caption{Utente che non riesce ad attaccare la funzione di login perché viene bloccato dopo un certo numero di tentativi.}
\end{figure}

La figura 3.2 mostra la simulazione dell'attacco della funzione di login da parte di un utente che inserisce credenziali errate per 5 volte consecutive, arrivando ad attivare il timeout del login.

\FloatBarrier

\subsubsection{Simulazione inserimento MFA errato}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_MFA_errato_1.png}
    \caption{Utente che inserisce correttamente le credenziali, ma sbaglia il codice MFA troppe volte.}
\end{figure}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_MFA_errato_2.png}
    \caption{Utente che inserisce correttamente le credenziali, ma sbaglia il codice MFA troppe volte.}
\end{figure}

Le figure 3.3 e 3.4 mostrano la simulazione di un utente che inserisce correttamente le credenziali, ma sbaglia il codice MFA per troppe volte consecutive, raggiungendo così lo stato di timeout. Questo scenario evidenzia l'importanza dei sistemi di autenticazione a più fattori, i quali diminuiscono la probabilità di successo di un attacco di forza bruta.

\FloatBarrier

\subsubsection{Simulazione attacco effettuato con successo sulla funzione di recupero password ed accesso all'account}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_recupero_password_e_login.png}
    \caption{Utente che attacca con successo la funzione di recupero password ed accede all'account appena compromesso.}
\end{figure}

La figura 3.5 mostra la simulazione di un utente che attacca con successo la funzione di recupero password, indovinando l'email ed il codice di recupero password. Successivamente, l'utente riesce ad accedere all'account appena compromesso inserendo l'email, la password appena cambiata ed indovinando il codice MFA. Questo scenario è molto improbabile, ma evidenzia come un attaccante determinato possa riuscire a compromettere un account anche in presenza di meccanismi di sicurezza avanzati.

\FloatBarrier

\subsubsection{Simulazione inserimento codice di recupero password errato}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_codice_recupero_password_errato1.png}
    \caption{Utente che inserisce il codice di recupero password errato troppe volte, andando a finire nello stato di timeout.}
\end{figure}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\columnwidth]{chapter3/immagini/Simulazione_codice_recupero_password_errato2.png}
    \caption{Utente che inserisce il codice di recupero password errato troppe volte, andando a finire nello stato di timeout.}
\end{figure}

\FloatBarrier

Le figure 3.6 e 3.7 mostrano la simulazione di un utente che effettua la procedura di recupero della password indovinando un'email valida, ma sbagliando il codice di recupero password per troppe volte consecutive, raggiungendo così lo stato di timeout.

\clearpage

%%%%%%%%%%%%%%% SAFETY %%%%%%%%%%%%%%%%%%%%

\subsection{Verifica di una proprietà di Safety}

La proprietà di \textit{Safety} rappresenta il concetto che "qualcosa di brutto non accada mai" durante l'esecuzione di un sistema. In altre parole, una proprietà di Safety garantisce che il sistema non raggiunga mai uno stato indesiderato o pericoloso. Nel contesto della funzione di login modellata tramite la catena di Markov, una proprietà di Safety potrebbe essere formulata come segue: "Un utente non deve mai superare il numero massimo di tentativi di login errati senza essere bloccato". Questa proprietà può essere rappresentata in PRISM tramite la seguente stringa: 
\begin{verbatim}
    P=? [ G !( "Timeout" & "AttaccoRiuscito" ) ]
\end{verbatim}

oppure anche con la seguente stringa:

\begin{verbatim}
    P=? [ F ( "AttaccoRiuscito" ) ] 
\end{verbatim}

Usando la funzione \textit{Verify} di PRISM, è stato possibile verificare la prima proprietà. Nella prima stringa ci chiediamo qual'è la probabilità che non valga mai il fatto che la funzione di login sia nello stato di timeout (denotato appunto dall'etichetta "Timeout", la quale è un alias per lo stato 20) e l'attaccante sia riuscito ad effettuare l'attacco con successo (denotato dall'etichetta "AttaccoRiuscito", alias per lo stato 24). In altre parole, questa proprietà garantisce che il sistema bloccherà l'utente dopo un certo numero di tentativi errati, prevenendo così accessi non autorizzati. Come si può osservare dalla figura 3.8, la probabilità è quasi 1, il che significa che è praticamente certo che l'utente verrà bloccato prima di riuscire ad accedere con successo.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.5\columnwidth]{chapter3/immagini/safety1.png}
    \caption{Verifica della proprietà di Safety tramite PRISM.}
\end{figure}

Nella seconda stringa, ci chiediamo qual'è la probabilità che prima o poi si raggiunge lo stato in cui l'attaccante è riuscito ad effettuare l'attacco con successo. Vediamo nella figura 3.9 che questa probabilità è praticamente 0, il che significa che è praticamente impossibile che l'attaccante riesca ad accedere al sistema senza essere bloccato.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.5\columnwidth]{chapter3/immagini/safety2.png}
    \caption{Verifica della proprietà di Safety tramite PRISM.}
\end{figure}

\FloatBarrier

%%%%%%%%%%%%%%% RESPONSE %%%%%%%%%%%%%%%%%%
\subsection{Verifica di una proprietà di response}

La proprietà di \textit{Response} rappresenta il concetto che "se qualcosa di buono accade, allora qualcosa di buono deve accadere sempre". In altre parole, una proprietà di response garantisce che se un evento desiderato si verifica, allora un altro evento desiderato deve seguire. Si è deciso di modellare la "un utente con le credenziali corrette deve riuscire ad accedere al sistema infinitamente spesso". Questa proprietà può essere rappresentata in PRISM tramite la seguente stringa: 
\begin{verbatim}
    P=? [ G F !("Timeout" & "LoginEffettuato" ) ]
\end{verbatim}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.5\columnwidth]{chapter3/immagini/response.png}
    \caption{Verifica della proprietà di Response tramite PRISM.}
\end{figure}

\FloatBarrier

Anche questa proprietà è stata verificata utilizzando la funzione \textit{Verify} di PRISM. La verifica ha confermato che la proprietà è soddisfatta, infatti figura 3.8 mostra che la probabilità che non valga infinitamente spesso il fatto di essere nello stato di timeout e contemporaneamente di aver effettuato il login con successo. Ciò significa che un utente con le credenziali corrette riuscirà sempre ad accedere al sistema, garantendo così l'accessibilità del processo di autenticazione.
